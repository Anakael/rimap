//! Imap `tag` declaration
//!

use std::{fmt::Display, iter::Iterator};

/// `Tag` with prefixed letter
/// # Example
/// a1, c1001
#[derive(Eq, PartialEq, Debug, Hash)]
pub(crate) struct Tag {
    prefix: char,
    index: u32,
}

impl Tag {
    /// Construct new `Tag`
    pub(crate) fn new(prefix: char, index: u32) -> Self {
        Self { prefix, index }
    }
}

impl Default for Tag {
    fn default() -> Self {
        Tag::new('a', 0)
    }
}

impl Display for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}{}", self.prefix, self.index)
    }
}

/// Each client command is prefixed with an identifer and a different tag is
/// generated by the client for each command. Every call `next` method will
/// return an unique `tag` for the command.
pub(crate) struct TagGenerator {
    prefix: char,
    index: u32,
}

impl TagGenerator {
    /// Construct new TagGenerator
    pub fn new(prefix: char, index: u32) -> Self {
        TagGenerator { prefix, index }
    }
}

impl Default for TagGenerator {
    fn default() -> Self {
        TagGenerator::new('a', 0)
    }
}

impl Iterator for TagGenerator {
    type Item = Tag;

    fn next(&mut self) -> Option<Self::Item> {
        let result = Tag::new(self.prefix, self.index);
        self.index += 1;
        Some(result)
    }
}
